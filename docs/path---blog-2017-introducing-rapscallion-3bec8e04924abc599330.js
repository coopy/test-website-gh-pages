webpackJsonp([0xe0c11b0d244d],{746:function(a,n){a.exports={data:{markdownRemark:{html:'<p>React has gained significant momentum over the four years since its initial release, and for good reason.  I’ll admit that I was initially a skeptic, particularly when it came to the strangeness that is JSX, but I was quickly won over by its codification of small, testable units of code, one-way flow of data, and composability.</p>\n<p>In fact, it is these very qualities that have allowed us at Formidable to build front-end applications of considerable size and complexity.  However, there has been one problem that has consistently reared its head in our client work: poor server-side rendering performance.</p>\n<p>There has been a lot of discussion and a handful of attempts at tackling this issue, but with SSR not in use at Facebook, it is understandable that the effort has been deprioritized.</p>\n<p>Fully addressing this issue should become simpler with the advent of React Fiber.  We’re excited to see what comes of that effort, but in the interim, there is a lot of value in addressing the issue of SSR performance with the React of today.</p>\n<p>And so, I’m happy to announce the initial release of Rapscallion, a new approach for server-side rendering React applications.  A quick run-down of the notable features:</p>\n<ul>\n<li>Rendering is <strong>asynchronous</strong> and non-blocking.</li>\n<li>Non-concurrent rendering speed is roughly <strong>50% faster</strong> than React’s <code class="language-text">renderToString</code>.</li>\n<li>Concurrent rendering speed is roughly <strong>60%-85% faster</strong>.</li>\n<li>A <strong>streaming</strong> interface is provided, so that you can start sending content to the client as soon as the request arrives.</li>\n<li>It provides a <strong>templating</strong> feature, so that you can wrap your component’s HTML in boilerplate without giving up the benefits of streaming.</li>\n<li>It provides a <strong>component caching</strong> API to further speed up SSR.</li>\n</ul>\n<p>The first few items show a lot of promise, but it is with caching where Rapscallion really shines.</p>\n<p>If you’d like to skip all this and give it a try, the docs are up on <a href="https://github.com/FormidableLabs/rapscallion">GitHub</a>.  Otherwise, read on.</p>\n<h2 id="prior-art"><a href="#prior-art" aria-hidden="true" class="anchor"><span aria-hidden=\'true\' class=\'anchor-icon\' /></a>Prior art</h2>\n<p>I would be remiss if I did not acknowledge the huge amount of work that has gone into addressing SSR performance.  Here’s a quick review of the packages of which I’m aware:</p>\n<h3 id="react-server"><a href="#react-server" aria-hidden="true" class="anchor"><span aria-hidden=\'true\' class=\'anchor-icon\' /></a><a href="https://github.com/redfin/react-server">react-server</a></h3>\n<p><code class="language-text">react-server</code> addresses the issue in a systematic way, and comes will all kinds of bells and whistles.  It still relies on React’s <code class="language-text">renderToString</code>, but allows you to compose your applications in a way that makes it easier to send data to the client incrementally.</p>\n<p>In truth, <code class="language-text">react-server</code> and <code class="language-text">rapscallion</code> are getting at the same problem from different directions, with little overlap.  In fact, the two might complement each other well.</p>\n<h3 id="react-ssr-optimization"><a href="#react-ssr-optimization" aria-hidden="true" class="anchor"><span aria-hidden=\'true\' class=\'anchor-icon\' /></a><a href="https://github.com/walmartlabs/react-ssr-optimization">react-ssr-optimization</a></h3>\n<p>From their docs: [react-ssr-optimization …] is a configurable ReactJS extension for memoizing react component markup on the server.  It also supports component templatization to further caching of rendered markup with more dynamic data.</p>\n<p>Basically, this package memoizes the output of <code class="language-text">renderToString</code> internals so that you can avoid duplicate work on a single node.  It is not, however, asynchronous, nor are the caching effects easily shared across nodes.</p>\n<h3 id="react-dom-stream"><a href="#react-dom-stream" aria-hidden="true" class="anchor"><span aria-hidden=\'true\' class=\'anchor-icon\' /></a><a href="https://github.com/aickin/react-dom-stream">react-dom-stream</a></h3>\n<p><code class="language-text">react-dom-stream</code> tries to solve the problem in a similar way to Rapscallion.  Rendering occurs asynchronously, and it even includes a caching feature similar to Rapscallion’s.</p>\n<p>However, it started as a fork of <code class="language-text">ReactDOMServer</code>, and this brings some architectural limitations that have caused difficulties.  Because it is a fork, it’s still based on <code class="language-text">react-dom-server@0.14.0</code> rendering code.  And memoization with <code class="language-text">react-dom-stream</code> is a synchronous affair, which precludes interoperability with external caching solutions.</p>\n<h2 id="hypernova"><a href="#hypernova" aria-hidden="true" class="anchor"><span aria-hidden=\'true\' class=\'anchor-icon\' /></a><a href="https://github.com/airbnb/hypernova">Hypernova</a></h2>\n<p>Hypernova is perhaps the most novel of the solutions listed here.  Instead of trying to address rendering speed in the context of your Node.js process, it farms out the work to a separate server.  What makes this especially interesting is how this approach opens the door to SSR from a Ruby or Python back-end, whereas these other solutions are constrained to JavaScript.</p>\n<hr>\n<p>If you find that Rapscallion doesn’t serve your needs, you would be well-served to look at these other solutions!</p>\n<h2 id="from-start-to-finish"><a href="#from-start-to-finish" aria-hidden="true" class="anchor"><span aria-hidden=\'true\' class=\'anchor-icon\' /></a>From start to finish</h2>\n<p>I started this project by considering what I’d want out of a SSR solution.  Obviously, I’d want it to be faster than the default implementation.  But this is Node.js that we’re talking about - a single-threaded environment - where synchronous solutions are not ideal.  So in addition to being faster, it also should be non-blocking.</p>\n<p>It would be nice if it were a near drop-in replacement, so long as that didn’t interfere with the other goals.  And it should definitely play nice with common async primitives like streams and promises.  Backpressure for streams, for example, should work out of the box.</p>\n<p>The original proof-of-concept was built on top of <a href="https://twitter.com/briancavalier">@briancavalier</a>’s fantastic FRP library, <a href="https://github.com/cujojs/most">most.js</a>.  Unfortunately, mine was a somewhat off-label use of most.js, and that introduced problems.  I needed a building-block that 1) was async, 2) could lazily evaluate its source(s), and 3) could be paused by the source if data is not ready.</p>\n<p>The first and second of these requirements were easily met by most.js, but the third was difficult to manage without some significant hackery.  Unfortunately, the third requirement was vital to supporting external caching strategies like Redis or memcached, so I needed to explore a couple of other options.</p>\n<p>The second version was a port to using generators.  It turned out beautifully, but introduced a significant performance regression.  I needed something generator-like, but not a generator.</p>\n<p>What I landed on was a custom <code class="language-text">Sequence</code> type that drew inspiration from AST traversal in programming language interpreters.  As an interpreter steps through the AST during evaluation, the state of the application is maintained on the call stack.  Roughly speaking, the stack itself is composed of frames, and each frame consists of a marker indicating where you are in the invocation of the corresponding function.</p>\n<p>This pattern is quite similar to what I wanted: given a root VDOM node, it needed to be traversed, evaluating any <code class="language-text">Component</code>s that it encountered and transforming the rest into text.  And since I was writing it from scratch, introducing mechanisms for pause/resume became simpler.</p>\n<h2 id="so-what-does-it-look-like"><a href="#so-what-does-it-look-like" aria-hidden="true" class="anchor"><span aria-hidden=\'true\' class=\'anchor-icon\' /></a>So what does it look like?</h2>\n<p>The simplest way to use Rapscallion is through its Promise interface:</p>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code class="language-javascript"><span class="token function">render</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>MyComponent <span class="token punctuation">{</span><span class="token operator">...</span>props<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">)</span>\n  <span class="token punctuation">.</span><span class="token function">toPromise</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>htmlString <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>htmlString<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>\n      </div>\n<p>This might be preferable in some cases, especially if you’re not dealing with an actual server environment, but if you’re using Express or Hapi, you’ll probably be more interested in the stream interface:</p>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code class="language-javascript">app<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">\'/example\'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">{</span>\n  <span class="token function">render</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>MyComponent <span class="token punctuation">{</span><span class="token operator">...</span>props<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">)</span>\n    <span class="token punctuation">.</span><span class="token function">toStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n    <span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>\n      </div>\n<p>There are a couple of reasons why this might be preferable to rendering to a Promise.  First, it should reduce the <a href="https://en.wikipedia.org/wiki/Time_To_First_Byte">TTFB</a> by a fair margin - amounting to the round-trip from client to server plus change.  Not only will the first byte arrive sooner, the last will as well.  In the case of a Promise, you can only start sending the first byte after all rendering has concluded, and the last byte has to wait until everything else has been sent.  If you’re streaming as you render, that’s not the case.</p>\n<p>During previous discussions about possibilities for async SSR, it had been noted that <code class="language-text">renderToString</code> attaches a <code class="language-text">data-react-checksum</code> attribute to the root DOM node of your component.  That’s not an option when you’re streaming, since the first bytes have already been sent by the time the checksum can be calculated.  Fortunately, a simple solution for this is provided: injecting the checksum into the DOM before your application is bootstrapped.  This technique is demonstrated in the <a href="https://github.com/FormidableLabs/rapscallion#example">template example</a>.</p>\n<h2 id="templates"><a href="#templates" aria-hidden="true" class="anchor"><span aria-hidden=\'true\' class=\'anchor-icon\' /></a>Templates</h2>\n<p>In every one of our client projects that uses SSR, we end up writing a function that takes the rendered output of a component and wraps it in some boilerplate HTML.</p>\n<p>This becomes somewhat difficult to achieve when streaming content.  Node.js gurus could probably perform some impressive <code class="language-text">Stream</code> acrobatics to get this done.  But why embrace complex when you can have simple?  Rapscallion provides render templates, and they look something like this:</p>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code class="language-javascript"><span class="token keyword">const</span> wrappedComponent <span class="token operator">=</span> template<span class="token template-string"><span class="token string">`\n&lt;div>\n  </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span> <span class="token function">render</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>MyComponent <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">)</span> <span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">\n&lt;/div>\n`</span></span><span class="token punctuation">;</span>\n<span class="token keyword">const</span> header <span class="token operator">=</span> <span class="token function">render</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>MyHeader <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">const</span> html <span class="token operator">=</span> template<span class="token template-string"><span class="token string">`\n&lt;html>\n</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>header<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">\n&lt;body>\n  </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>wrappedComponent<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">\n&lt;/body>\n&lt;/html>\n`</span></span><span class="token punctuation">;</span></code></pre>\n      </div>\n<p>The full breadth of template functionality is <a href="https://github.com/FormidableLabs/rapscallion#template">documented in the README</a>.</p>\n<h2 id="caching"><a href="#caching" aria-hidden="true" class="anchor"><span aria-hidden=\'true\' class=\'anchor-icon\' /></a>Caching</h2>\n<p>Now for the fun bit.</p>\n<p>All of the above will only get you so far.  Ultimately, the rendering performance of React applications is fundamentally constrained by CPU resources.  We are still working on optimizing Rapscallion’s performance characteristics under severe load, but there’s only so much that can be done.  We want strong performance guarantees for when our servers encounter peak traffic.  That’s where caching comes in.</p>\n<p>Rapscallion’s caching is completely opt-in and is performed on a per-component level.  You see, we noticed that there were huge portions of our applications that either 1) always rendered in the same way, or 2) had few variations.  That sounds like a perfect use-case for memoization.</p>\n<p>To enable caching, you define a <code class="language-text">cacheKey</code> prop on your VDOM element - this can either be a <code class="language-text">&lt;Component /&gt;</code> or a vanilla DOM node like a <code class="language-text">&lt;div /&gt;</code>.  This <code class="language-text">cacheKey</code> uniquely and globally identifies the expected content of the render - not just for the node you’re labeling.  The <code class="language-text">cacheKey</code> should also incorporate whatever props or context might influence how a component is rendered.</p>\n<p>Here’s what it might look like:</p>\n<div class="gatsby-highlight">\n      <pre class="language-javascript"><code class="language-javascript"><span class="token keyword">const</span> <span class="token function-variable function">Child</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> val <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span>\n  <span class="token operator">&lt;</span>div<span class="token operator">></span>\n    ComponentA\n  <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>\n<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token keyword">const</span> <span class="token function-variable function">Parent</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> toVal <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span>\n  <span class="token operator">&lt;</span>div cacheKey<span class="token operator">=</span><span class="token punctuation">{</span> <span class="token template-string"><span class="token string">`Parent:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>toVal<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span> <span class="token punctuation">}</span><span class="token operator">></span>\n    <span class="token punctuation">{</span>\n      _<span class="token punctuation">.</span><span class="token function">range</span><span class="token punctuation">(</span>toVal<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>val <span class="token operator">=></span> <span class="token punctuation">(</span>\n        <span class="token operator">&lt;</span>Child cacheKey<span class="token operator">=</span><span class="token punctuation">{</span> <span class="token template-string"><span class="token string">`Child:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>val<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span> <span class="token punctuation">}</span> key<span class="token operator">=</span><span class="token punctuation">{</span>val<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span>\n      <span class="token punctuation">)</span><span class="token punctuation">)</span>\n    <span class="token punctuation">}</span>\n  <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>\n<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\nPromise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n  <span class="token comment">// The first render will take the expected duration.</span>\n  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">render</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>Parent toVal<span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">5</span><span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toPromise</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n  <span class="token comment">// The second render will be much faster, due to multiple cache hits.</span>\n  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">render</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>Parent toVal<span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">6</span><span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toPromise</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n  <span class="token comment">// The third render will be near-instantaneous, due to a top-level cache hit.</span>\n  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">render</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>Parent toVal<span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">6</span><span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toPromise</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>\n      </div>\n<p>Remember, caching <em>always</em> costs you something - you’re constructing keys and storing values.  There’s overhead, so make sure the extra work is worth it.  In other words:</p>\n<ul>\n<li><em>Do</em> cache your <code class="language-text">&lt;StaticHeader /&gt;</code> component.</li>\n<li><em>Don’t</em> cache your <code class="language-text">&lt;IChangeForEveryRender /&gt;</code> component.</li>\n<li>And of course, there’s a middle-ground component that only produces a small set of possible HTML outputs.  You should cache those too.</li>\n</ul>\n<p>Finally, I’ll add that a falsey <code class="language-text">cacheKey</code> value will bypass the caching mechanism.  This means that you can <em>conditionally</em> cache a component.  So <code class="language-text">&lt;MyComponent cacheKey={ someCondition ? myCacheKey : null } /&gt;</code> is completely permissible.</p>\n<p>By default, Rapscallion caches content in memory, but an API is also provided to wire up any external caching service you might prefer, like <a href="https://redis.io/">Redis</a>, <a href="https://memcached.org/">memcached</a> or <a href="https://aws.amazon.com/elasticache/">ElastiCache</a>.  If you do go with a networked solution, the computation cost for rendering a specific component becomes a one-off, and the benefit is shared across all server nodes!</p>\n<p>A Redis example is <a href="https://github.com/FormidableLabs/rapscallion#setcachestrategy">included in the README</a>.</p>\n<h2 id="caveats"><a href="#caveats" aria-hidden="true" class="anchor"><span aria-hidden=\'true\' class=\'anchor-icon\' /></a>Caveats</h2>\n<p>Rapscallion is in good enough shape that we’re ready to share, but there’s still work to do.  Here are some things to keep in mind:</p>\n<ul>\n<li>If you stream content to the client and your render fails at a mid-way point, you’ve already sent an HTTP 200 response and a good portion of the HTML.  This means you’ll have to introduce some other mechanism for communicating an error state to the client.</li>\n<li>Rapscallion is only a couple of weeks old!  We’re excited about the opportunities that it affords, but please consider it beta-quality until there’s a chance for its stability and performance to be vetted by a larger group.</li>\n<li>Since renders don’t block the event loop, Rapscallion will answer every request.  This means that if you encounter too many clustered requests (read: hundreds simultaneously), rendering for each one will slow to a crawl.  If it gets bad enough, you might encounter out-of-memory errors.  On the other hand, if your server is this overloaded, you’ll have huge problems no matter which renderer you use.</li>\n<li>We’re still working out some spots of perf strangeness.  Expect to see improvements and tweaks in this area.</li>\n</ul>\n<h2 id="try-it"><a href="#try-it" aria-hidden="true" class="anchor"><span aria-hidden=\'true\' class=\'anchor-icon\' /></a>Try it!</h2>\n<p>Here’s another link to the <a href="https://github.com/FormidableLabs/rapscallion">GitHub repo</a>.  If you encounter a bug, please <a href="https://github.com/FormidableLabs/rapscallion/issues/new">file an issue</a>.</p>\n<p>If you need help getting started, or if you just have a question, you can find us on <a href="https://gitter.im/FormidableLabs/rapscallion">Gitter</a>.  You can also find me on Twitter as <a href="https://twitter.com/divmain">@divmain</a> if you’d like to reach out directly.</p>\n<p>Cheers!</p>',fields:{slug:"/blog/2017/introducing-rapscallion/"},frontmatter:{id:36,authorId:14,categoryIds:[5,4],date:"2017-02-28",pageDescription:"Rapscallion is a new approach for server-side rendering React applications",pageKeywords:"react, developer, tooling, packager, performance",pageTitle:"Introducing Rapscallion - a new approach for server-side rendering React applications",path:"/2017/introducing-rapscallion/",title:"Faster React SSR with Rapscallion"}}},pathContext:{slug:"/blog/2017/introducing-rapscallion/",prev:{fields:{slug:"/blog/2016/12/01/introducing-whackage/"},frontmatter:{authorId:1,categoryIds:[4,3,2,5,6,7],date:"2016-12-01",id:35,title:"Introducing Whackage"}}}}}});