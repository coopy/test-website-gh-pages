webpackJsonp([47708891912263],{762:function(e,t){e.exports={data:{markdownRemark:{html:'<p>\n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; z-index: 0 !important;; max-width: 800px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 50%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsSAAALEgHS3X78AAABkUlEQVQoz32Sy07CQBSG+/5bF27YCIKAohAJgoBSbuFeWnqllBaEigQkPsHvnEKhAePiTyczJ1+/M3M4UZ1A0iyM9ClkYwplvI82ceAsv9AeSOgMFbZnH8/8UH0wtMcR8BymWzOoDHh1HUIsfo9UOotKs3+EquYl3A/n2wXNRrqFu+QjIpEYXHcFSZIRjibRHxn/AkmK29udCgxmN5B1vJZ5fG93EGcr8PMdsu8NPGRyXm2wm2DLxOKC7dKfKZPZEvWOgEazDX7xg5C6QW26xksuj1ypxmqdAMj23oAiapNLILVMMRm0VKmDF1TUZ1so9hJTy0YskUK1JXg2fugdBMVEXx7/bUhAap3W+UIZc9uBu/zE/MOFYZi4id2jK2pHsyEDDmQTXck4Pcq5JX1NZ8FGRkaOQdfrDRYLF+nMM6LJJ9beoc2DXW80RkfU92NDB8FZ8k1pTfdZrDRQLL7hNppAOJ6C7N3h/u6GCtmNPbv2UDsBz2cxCNatOQrlKvhmj1m7kFmtb0et9tg4kV1L0PALo/e4aM5OF9IAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px transparent;"\n        alt="OAuth and PKCE with React Native"\n        title=""\n        src="/static/cybersecurity-mobile_1024-f8190a39e90a4c481b4b72caaf19cb06-fc76f.png"\n        srcset="/static/cybersecurity-mobile_1024-f8190a39e90a4c481b4b72caaf19cb06-290b0.png 200w,\n/static/cybersecurity-mobile_1024-f8190a39e90a4c481b4b72caaf19cb06-14201.png 400w,\n/static/cybersecurity-mobile_1024-f8190a39e90a4c481b4b72caaf19cb06-fc76f.png 800w,\n/static/cybersecurity-mobile_1024-f8190a39e90a4c481b4b72caaf19cb06-dc97d.png 1024w"\n        sizes="(max-width: 800px) 100vw, 800px"\n      />\n    </span>\n  </span>\n  </p>\n<p><a href="https://oauth.net/">OAuth</a> is an authorization protocol that utilizes a third party to gain access to user information without exposing the user’s password. The OAuth website describes the process with a great analogy:</p>\n<blockquote>\n<p>Many luxury cars today come with a valet key. It is a special key you give the parking attendant and unlike your regular key, will not allow the car to drive more than a mile or two. Some valet keys will not open the trunk, while others will block access to your onboard cell phone address book. Regardless of what restrictions the valet key imposes, the idea is very clever. You give someone limited access to your car with a special key, while using your regular key to unlock everything.</p>\n</blockquote>\n<p>Our new React Native library, <a href="https://github.com/FormidableLabs/react-native-app-auth">react-native-app-auth</a>, allows you to securely communicate with OAuth 2.0 and OpenID Connect. It bridges existing native authentication implementations for iOS and Android by OpenID and benefits from the same security enhancements.</p>\n<p>But why did we bother? What’s so tricky about OAuth on mobile devices? The rest of this article will give you a brief overview of OAuth and the additional complications it brings to mobile devices.</p>\n<h3 id="the-difference-between-oauth-and-openid"><a href="#the-difference-between-oauth-and-openid" aria-hidden="true" class="anchor"><span aria-hidden=\'true\' class=\'anchor-icon\' /></a>The difference between OAuth and OpenID</h3>\n<p>The lines seem blurred between <a href="https://oauth.net/">OAuth</a> and <a href="http://openid.net/">OpenID</a>, as they are frequently used together and have some common authors. To clarify: OpenID allows you to use an existing account to sign in to multiple websites without needing to create new passwords. Anyone can register to be an OpenID provider. This is how the “log in with Google/Facebook/Github” buttons have come about. These companies have registered to be OpenID providers and allow other websites to authenticate through them. OAuth, on the other hand, is an authorization protocol that dictates the exact API of the authorization server, how and when tokens get exchanged, and what security measures need to be taken to mitigate risks of malicious agents hijacking tokens.</p>\n<h3 id="oauth-the-2-minute-overview"><a href="#oauth-the-2-minute-overview" aria-hidden="true" class="anchor"><span aria-hidden=\'true\' class=\'anchor-icon\' /></a>OAuth: the 2 minute overview</h3>\n<p>Imagine you want to log into Medium using your Google account. We know that Google is an OpenID provider that implements the OAuth2 spec. How does that workflow work? Our example has 4 characters:</p>\n<ul>\n<li>Client (Medium) - the third party application that would like access to a user’s account. It needs permission in order to do so</li>\n<li>The Resource Server (Google API) - the API server used to access the user’s information</li>\n<li>The Authorization Server (Google UI) - the server that presents the interface where the user approves or denies the request</li>\n<li>The Resource Owner (you) - the person that is giving access to some portion of their account</li>\n</ul>\n<h5 id="step-0-only-done-once-a-developer-registers-the-app-with-the-service"><a href="#step-0-only-done-once-a-developer-registers-the-app-with-the-service" aria-hidden="true" class="anchor"><span aria-hidden=\'true\' class=\'anchor-icon\' /></a>Step 0 (only done once): a developer registers the app with the service</h5>\n<p>A Medium developer would have had to register the application on Google. That would include registering basic information such as application name, website, a logo, etc. In addition, they must register a redirect URI to be used for redirecting users.</p>\n<h5 id="step-1-the-user-clicks-on-the-log-in-with-google-button"><a href="#step-1-the-user-clicks-on-the-log-in-with-google-button" aria-hidden="true" class="anchor"><span aria-hidden=\'true\' class=\'anchor-icon\' /></a>Step 1: the user clicks on the “log in with Google” button</h5>\n<p>The user will be redirected to a Google-hosted page and prompted to log in. The request includes:</p>\n<ul>\n<li>Client ID - received from Google after setting up Step 0</li>\n<li>Redirect URI - the URI back to Medium</li>\n<li>Scope - how much of the user’s information the website would like, e.g. email</li>\n</ul>\n<h5 id="step-2-the-user-is-redirected-back-to-medium"><a href="#step-2-the-user-is-redirected-back-to-medium" aria-hidden="true" class="anchor"><span aria-hidden=\'true\' class=\'anchor-icon\' /></a>Step 2: The user is redirected back to Medium</h5>\n<p>After a successful authentication, the user is redirected back to Medium using the code.</p>\n<h5 id="step-3-the-token-is-requested-using-the-auth-code"><a href="#step-3-the-token-is-requested-using-the-auth-code" aria-hidden="true" class="anchor"><span aria-hidden=\'true\' class=\'anchor-icon\' /></a>Step 3: The token is requested using the auth code</h5>\n<p>Once the client had verified that the code received is authentic, it can make the request to exchange the auth code for the auth token.</p>\n<h5 id="step-4-the-auth-server-returns-an-access-token"><a href="#step-4-the-auth-server-returns-an-access-token" aria-hidden="true" class="anchor"><span aria-hidden=\'true\' class=\'anchor-icon\' /></a>Step 4: The auth server returns an access token</h5>\n<p>The auth server will verify this request and return the access token as well as a refresh token and expiry date when applicable.</p>\n<h3 id="native-apps-and-pkce"><a href="#native-apps-and-pkce" aria-hidden="true" class="anchor"><span aria-hidden=\'true\' class=\'anchor-icon\' /></a>Native Apps and PKCE</h3>\n<p>The second step of our authentication flow above involves linking back to our application with an auth code. This is a problem for native applications because the nature of how they are distributed through public stores prevents individual instances of applications from having unique (or secret) credentials. That means that it is impossible to guarantee that linking back into a native app will be caught by the application intended. Android prompts the user to choose between multiple apps claiming the same scheme, but iOS does not. If a malicious application gets itself registered as a handler of those URLs, they could intercept the handoff of the authorization code.</p>\n<p>Since we cannot guarantee that the auth code is received by the correct application, the security problem needs to be handled elsewhere. <a href="https://www.oauth.com/oauth2-servers/pkce/">PKCE</a> to the rescue! PKCE (pronounced Pixie, believe it or not), or Proof Key for Code Exchange, is a spec that is designed to mitigate exactly this risk by preventing the malicious application, having already gotten hold of the auth token, from exchanging it for a more substantial token.</p>\n<p>This works exactly as the auth flow described above, but with an additional parameter added to certain messages. When the native application first loads the login page in the browser, it also generates a <code class="language-text">code_verifier</code> string and passes that as a parameter on the URL. The Authorization Server stores away this string before returning the code back to the native application. When the native application then exchanges the code for the access token, it will include the <code class="language-text">code_verifier</code> string on that call. If the <code class="language-text">code_verifier</code> is missing or doesn’t match the previously recorded one, the Authorization Server will not return the access token. So, even if a malicious application is able to obtain a code, without the corresponding <code class="language-text">code_verifier</code> it will be unable to turn that code into an access token, and thus unable to access the business or personal data accessed through the APIs.</p>\n<h3 id="oauth2-and-react-native"><a href="#oauth2-and-react-native" aria-hidden="true" class="anchor"><span aria-hidden=\'true\' class=\'anchor-icon\' /></a>OAuth2 and React Native</h3>\n<p>Since a built React Native application is indistinguishable from a native app, it is also challenged by the same security vulnerabilities. <a href="https://github.com/openid">OpenID</a> has built tools to work with OAuth2 on the <a href="https://github.com/openid/AppAuth-JS">web</a>, on <a href="https://github.com/openid/AppAuth-Android">Android</a> and <a href="https://github.com/openid/AppAuth-iOS">iOS</a>. However, the existing JavaScript module was incompatible with React Native, which motivated us to build our own <a href="https://github.com/FormidableLabs/react-native-app-auth">library</a> - a React Native wrapper, bridging the native iOS and Android libraries - to allow you to easily and securely communicate using OAuth2 spec in React Native.</p>',fields:{slug:"/blog/2018/oauth-and-pkce-with-react-native/"},frontmatter:{id:56,authorId:23,categoryIds:[1,3,4,5,7,19],date:"2018-01-16",pageDescription:"react-native-app-auth is a React Native library that allows you to securely communicate with OAuth2.0 and OpenID Connect.",pageKeywords:"OAuth, PKCE, React Native, Authorization, OpenID, Authorization Protocol",pageTitle:"OAuth and PKCE with React Native",path:"/2018/oauth-and-pkce-with-react-native/",title:"OAuth and PKCE with React Native"}}},pathContext:{slug:"/blog/2018/oauth-and-pkce-with-react-native/",prev:{fields:{slug:"/blog/2017/spectacle-4-has-arrived/"},frontmatter:{authorId:22,categoryIds:[4,5,14],date:"2017-11-14",id:55,title:"Spectacle 4.0 Has Arrived"}}}}}});