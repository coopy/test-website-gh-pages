webpackJsonp([0xafa1517dc26b],{707:function(e,t){e.exports={data:{markdownRemark:{html:'<p>I love D3 — it was one of the reason I became a developer. It introduced me to the concept of functional UI. And, given the direction of the Front-End ecosystem, re-rendering based on diffed arrays (if not diffing the resultant SVG) <a href="https://medium.com/@patcito/reacteurope-interview-17-sebastian-markb%C3%A5ge-23bef96905af">was clearly ahead of its time and part of the inspiration for React</a>.</p>\n<p>On the other hand, I’ve never liked the <code>selectAll()</code> <code>enter()</code> <code>update()</code> <code>exit()</code> <code>transition()</code> and <code>data()</code> apis. With great deference to Mike Bostock&#8217;s N dimensional hyper-brain, I&#8217;ve never found it especially easy to reason about or explain to others.</p>\n<p>This came to a head breaking ground on a recent client project. It went like this:</p>\n<blockquote><p>Me: “We&#8217;re about to start a really complex project. A lot of the interface will be in D3. You know SVG and CSS, so this shouldn&#8217;t be too hard to explain.”</p>\n<p>Designer: &#8220;Ok!&#8221;</p>\n<p class="t-small-caps t-dim align-center"><strong>Five minutes later…</strong></p>\n<p>Me: “…and then <code>enter()</code>, which is kind of the beginning of the magic and obscures an internal looping over the data…”</p>\n<p class="t-small-caps t-dim align-center"><strong>Ten minutes later…</strong></p>\n<p>Me: “&#8230;so what I&#8217;m trying to say is that when you say <code>node.append(\'g\')</code>, you’re really not talking about a single node. Node is singular, but it&#8217;s actually an array. And you can think of it as singular, because again, there is an invisible looping over the data that is happening here. That’s why all of these lambdas have access to a particular data point as the markup travels through the chain of functions that constructs it&#8230;”</p>\n<p class="t-small-caps t-dim align-center"><strong>Five minutes later…</strong></p>\n<p>Me: “Let me think more about this and get back to you.”</p></blockquote>\n<p>Upon reflection, a few things stuck out. Keeping track of adding and removing of data under the hood in <code>update()</code> and <code>exit()</code> in D3’s model is more like React’s model than jQuery’s model. D3 needed its own model for <code>.transition()</code> to work magically (i.e., intelligently re-rendering every time the data changes). The whole D3 framework is built around making those behaviors work without effort.</p>\n<p>Since D3 has it’s own DOM model (and in part because it uses <a href="https://github.com/mbostock/smash">smash</a>, a custom build system with 171 GitHub stars to D3’s 37,880 at last count), developers are shipping a lot of extra methods. In fact, <a href="https://github.com/mbostock/d3/blob/master/d3.min.js">the minified distribution is 151 kb</a>. Back in 2010, this was surely necessary, but I started to think it might not be necessary now that we have React. Generally, switching to a more modular modern build system will help with this, and <a href="https://github.com/mbostock/d3/milestones/4.0">it’s on the roadmap to D3 V4.0</a> However, regardless of the build, it would be nice to not ship multiple DOM interface abstractions if possible.</p>\n<p>D3’s core contribution is not its DOM model but the math it brings to the client — things like the <a href="http://bl.ocks.org/mbostock/4339184">Reingold Tilford tidy tree layout algorithm</a> and <a href="https://github.com/mbostock/d3/wiki/Force-Layout#linkDistance">a novel alternative to embedded spring forces</a> on force layouts. What if we could use that math and delegate all the rendering to React? If we could componentize everything, it would mean writing SVG as markup and getting the designers back in the game. React would take care of the rest under the hood, and it would probably mean D3 could be broken out into nice little modules that simply return math. It seemed promising, so I set off to try it.</p>\n<p>Here are three of the results. These keep things simple to show the concept &#8211; no transitions, no <code>enter()</code> or <code>exit()</code> or <code>transition()</code> &#8211; those will be covered in the next two blog posts. This is just an aperitif.</p>\n<h2 id="a-dendogram"><a href="#a-dendogram" aria-hidden="true" class="anchor"><span aria-hidden=\'true\' class=\'anchor-icon\' /></a>A Dendogram</h2>\n<p><a class="jsbin-embed" href="http://jsbin.com/civita/1/embed?js,output">A Dendogram on JS Bin</a><script src="http://static.jsbin.com/js/embed.min.js?3.35.13"></script></p>\n<p>How it works:</p>\n<ol>\n<li>Go fetch the data</li>\n<li>Pass the data to the instantiation of a component called <code>&lt;Tree /&gt;</code></li>\n<li><code>&lt;Tree /&gt;</code>sets up the layout (i.e. functions that return the math)</li>\n<li>On <code>render</code>, construct the SVG by calling <code>this.drawNodes()</code> and <code>this.drawLinks()</code>…</li>\n<li>&#8230;which map over the nodes and links data respectively, instantiating a <code>&lt;Node /&gt;</code> and <code>&lt;Link /&gt;</code> component for each element in each array</li>\n<li>The <code>&lt;Node /&gt;</code> and <code>&lt;Link /&gt;</code> components take props, and fill in the attributes.</li>\n</ol>\n<p>SVG gets to be SVG, which is much more concrete. Previously, I had to keep that in my head. Also, no more lambdas because props.</p>\n<h2 id="force-layout"><a href="#force-layout" aria-hidden="true" class="anchor"><span aria-hidden=\'true\' class=\'anchor-icon\' /></a>Force Layout</h2>\n<p><a class="jsbin-embed" href="http://jsbin.com/vaxuhu/1/embed?js,output">Force Layout on JS Bin</a><script src="http://static.jsbin.com/js/embed.min.js?3.35.13"></script></p>\n<p>How it works:</p>\n<ol>\n<li>Go fetch the data</li>\n<li>Pass the data to the instantiation of a component called <code>&lt;Graph /&gt;</code></li>\n<li><code>&lt;Graph /&gt;</code> sets up the layout (i.e. functions that return the math) on <code>componentDidMount</code> and calls <code>.start()</code></li>\n<li><code>.start()</code> forces the component to <code>render</code> on every &#8216;tick&#8217;</li>\n<li>On <code>render</code>, call <code>drawNodes</code> and <code>drawLinks</code>, which map over the arrays of links and nodes produced by D3 on each tick and instantiate a component for each</li>\n<li>The <code>&lt;Node/&gt;</code> and <code>&lt;Link/&gt;</code> components contain the SVG markup</li>\n</ol>\n<p>I’m not completely sure whether or not there are performance gains achieved by React. Since the components are subject to diffing, it’s possible only the attributes are changing. At any rate, it seems to be roughly on par with D3’s frame rate.</p>\n<h2 id="treemap"><a href="#treemap" aria-hidden="true" class="anchor"><span aria-hidden=\'true\' class=\'anchor-icon\' /></a>Treemap</h2>\n<p><a class="jsbin-embed" href="http://jsbin.com/detixi/embed?js,output">Treemap on JS Bin</a><script src="http://static.jsbin.com/js/embed.min.js?3.35.13"></script></p>\n<h2>Conclusion</h2>\n<p>I’ve looked at, and am not a fan of, many of the D3 &amp; React strategies out there that simply wrap D3 in components. They ignore the hard problems and customizability of D3 that we’ll cover in <em>Part II: Transitions</em>. I’m incredibly excited for this future, especially because it means <a href="https://formidable.com/blog/2015/03/01/launching-radium/">using Radium for computed styles</a> as well. All together, this yields a concrete yet highly expressive toolchain for interactive information design.</p>',fields:{slug:"/blog/2015/05/21/react-d3-layouts/"},frontmatter:{id:5,authorId:13,categoryIds:[10,1],date:"2015-05-21",pageDescription:"",pageKeywords:"",pageTitle:"",path:"/2015/05/21/react-d3-layouts/",title:"ReactJS and D3 Part I: Layouts"}}},pathContext:{slug:"/blog/2015/05/21/react-d3-layouts/",prev:{fields:{slug:"/blog/2015/03/01/launching-radium/"},frontmatter:{authorId:13,categoryIds:[12,1],date:"2015-03-01",id:4,title:"Inline Styles are the Future"}}}}}});