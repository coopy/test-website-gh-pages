webpackJsonp([0xd9be35586ca3],{718:function(e,t){e.exports={data:{markdownRemark:{html:'<h2 id="just-use-react-router"><a href="#just-use-react-router" aria-hidden="true" class="anchor"><span aria-hidden=\'true\' class=\'anchor-icon\' /></a>“Just use React Router!”</h2>\n<p>This is how most conversations about routing end in the React/Redux ecosystem. There’s no doubt that React Router is the standard-bearer for SPA routing in the React world, and there’s more to its success than its early arrival on the scene or its SEO-friendly name. React Router offers strong community support, thorough documentation, useful components like <code class="language-text">&lt;Link&gt;</code>, and advanced features like async routes. If you’re managing state in React alone, it’s hard to go wrong with React Router.</p>\n<p>That doesn’t mean that React Router is the final answer to the routing question. How many times have you heard the following?</p>\n<blockquote>\n<p>  “Instead of writing a React application, I’m writing a React Router application!”</p>\n</blockquote>\n<p>I raised my eyebrows after hearing this quote more than once. Given that we needed routing for our new project, I wanted to ensure that our routing library wouldn’t dictate our app’s architecture or lock us into rigid design decisions. I investigated what a “React Router” app looks like and how it compares to a vanilla React app to see if these fears held any truth.</p>\n<h2 id="look-at-me-im-your-architecture-now"><a href="#look-at-me-im-your-architecture-now" aria-hidden="true" class="anchor"><span aria-hidden=\'true\' class=\'anchor-icon\' /></a>Look at Me, I’m Your Architecture Now</h2>\n<p>Consider the React ecosystem before state containers like Redux exploded in popularity. Even in pure React apps, routing makes sense as a top-level concern, as you derive a large portion of your UI from which route is active. React Router sits at the top level as expected, but then exerts further control of your view hierarchy by splitting your UI by route boundaries. Consider this basic snippet:</p>\n<div class="gatsby-highlight">\n      <pre class="language-js"><code class="language-js"><span class="token operator">&lt;</span>Router history<span class="token operator">=</span><span class="token punctuation">{</span><span class="token function">browserHistory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">></span>\n    <span class="token operator">&lt;</span>Route path<span class="token operator">=</span><span class="token string">"/"</span> component<span class="token operator">=</span><span class="token punctuation">{</span>App<span class="token punctuation">}</span><span class="token operator">></span>\n        <span class="token operator">&lt;</span>Route path<span class="token operator">=</span><span class="token string">"taco/:name"</span> component<span class="token operator">=</span><span class="token punctuation">{</span>Taco<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span>\n    <span class="token operator">&lt;</span><span class="token operator">/</span>Route<span class="token operator">></span>\n<span class="token operator">&lt;</span><span class="token operator">/</span>Router<span class="token operator">></span></code></pre>\n      </div>\n<p>Is your first thought to pass <code class="language-text">Taco</code> some props? It’s my first instinct. Isn’t that what you do to child components in React?</p>\n<p>The issue is that you’re passing a component class instead of a child element to <code class="language-text">&lt;Route&gt;</code>. The <code class="language-text">&lt;Route&gt;</code> instantiates <code class="language-text">Taco</code>, not you. This means that the <code class="language-text">Taco</code> component knows nothing about the outside world besides what React Router tells it (params, query strings, etc). The <code class="language-text">Taco</code> component class is between a rock and a hard place: it needs to pass props to its children, but it gets no help from its parent component.</p>\n<p>Why don’t route components participate in the normal top-to-bottom-flow of props to children? It turns out that the authors of React Router view this restriction as an architectural decision.</p>\n<p>Maintainer Ryan Florence says that “you should think of your route components as entry points into the app that don’t know or care about the parent, and the parent shouldn’t know/care about the children.”</p>\n<p>Maintainer Jimmy Jia (taion) agrees: “the actual anti-pattern is passing props through route boundaries – in general you just shouldn’t be doing this.”</p>\n<p>Maintainer Tim Dorr believes that this boundary enforces the Single Responsibility Principle: “I’d try to keep route components aware of only router-provided props and try to maintain SRP.”</p>\n<p>These architectural decisions might make sense when you distinguish “smart” or “container” components from “dumb” ones. Smart components are “entry points” that can independently bootstrap their children’s props. “Dumb” components are presentational; they take props and return UI.</p>\n<p>Everything changes when you use a state container like Redux. If you treat your Redux application as a pure function that accepts state and returns a UI, <strong>every component is a dumb component.</strong> Like heat, your state rises to the top, and your state container absorbs it and manages its logic. What’s the point of a container component if Redux controls all of your state?</p>\n<p>In fact, a container component <em>violates</em> the Single Responsibility Principle when it assumes responsibilities of the state container. It <strong>couples your view layer to your state layer</strong>.</p>\n<p>In a world of dumb components, the React Router architecture stops making sense.</p>\n<p>Besides issues of route boundaries and container components, the top-level <code class="language-text">&lt;Router&gt;</code> component hogs all of the routing state: URL, parameters, query strings, etc. Your state container can’t talk to this second source of truth (!) without interacting with the view layer. This has real consequences for the viability of pure-functional patterns in Redux.</p>\n<h2 id="we-need-to-go-deeper"><a href="#we-need-to-go-deeper" aria-hidden="true" class="anchor"><span aria-hidden=\'true\' class=\'anchor-icon\' /></a>We Need to Go Deeper</h2>\n<p>In our most recent Redux projects, we follow a simple architectural guideline: <em>derive your application from the URL</em>. This isn’t a radical idea, but React Router makes it difficult.</p>\n<p>We use <a href="https://github.com/reactjs/reselect">Reselect</a> to derive all of our React props from the Redux store. When Reselect selectors live right above the top-level component, everything is simple: the selector takes the state (or a previous selector) as a parameter and returns derived data for components to consume.</p>\n<p>Unfortunately, at the top level, we cannot grab the URL state that React Router manages. Instead, the selector must live underneath both the store and the <code class="language-text">&lt;Router&gt;</code> component. The selector becomes a function of both router props and Redux state. While it couples your view layer to the store, it at least allows us to derive our UI from URL state.</p>\n<p>In a pragmatic sense, this integration works. However, React Router makes other interesting Redux patterns impossible.</p>\n<h2 id="this-line-doesnt-exist"><a href="#this-line-doesnt-exist" aria-hidden="true" class="anchor"><span aria-hidden=\'true\' class=\'anchor-icon\' /></a>This Line Doesn’t Exist</h2>\n<p>In the spirit of decoupling the state container and the view layer, we wrote abstractions for data fetching that ditch the pattern of shoving AJAX requests into <code class="language-text">componentDidMount()</code>. We wanted to know which route needs which data without consulting a React component at all, and we wanted to derive what data to fetch using selectors (the same way we derive our props).</p>\n<p>In a more generic sense, we wanted to derive which actions to take next after the entire state tree changes. We needed a state-aware “reaction” system.</p>\n<p>To accomplish this, we wrote a store enhancer for <code class="language-text">redux-loop</code> (a subject for another blog post) that does the following:</p>\n<ul>\n<li>Intercepts the state returned by the app&#8217;s child reducers before it&#8217;s assigned to the store.</li>\n<li>Passes this state to the provided selectors, which return plain actions.</li>\n<li>Schedule these actions for `redux-loop` to dispatch by returning a declarative `Effect`.</li>\n</ul>\n<p>We use this pattern to solve complex problems, including route-specific data dependencies and complex local caching.</p>\n<p>Now imagine this system next to React Router. See the problem yet?</p>\n<p>For these “reactions” to be effective, they must see the entire state tree, <strong>especially the URL state.</strong> Where is the URL state when using React Router? <strong>Stuck in the view layer.</strong> The line we need from router state to Redux state doesn’t exist.</p>\n<p>This diagram outlines the problem:</p>\n<figure id="media-604" class="align-none" style="max-width:683px;">\n  <span class="gatsby-resp-image-wrapper" style="position: relative; display: block; z-index: 0 !important;; max-width: 683px; margin-left: auto; margin-right: auto;">\n    <span class="gatsby-resp-image-background-image" style="padding-bottom: 94.14348462664715%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAATCAYAAACQjC21AAAACXBIWXMAAAsSAAALEgHS3X78AAABlklEQVQ4y5WUW4+CQAyF5///PSMaH0zQB4KX4AUFVBzzdXNIHXE326SZC+1pT9shxESez+egSN/3sSiKWFXVx3fZeAmPx8OctI7Jfr8fAMcEX8BZQ13X8Xg8xsvlEq/Xa7zdbvF+vw/adZ1luNvt3u6l+KMEbNv2B5ADgOy5BETKWcF09t9JBj8Ccg4YkCqZof8VygSQ1jDWFISoi8UiLpdL0zzPbV2v10ZVYB9N+dY1jKGJns9nWwkCfW+b+oc0M3WcMxQAOp1OBqSSNE1jd2StugsjpJGgI0DAANpsNlZ8gAR4OBysJAC/AfrsNFOeNt/IAto+OMGwJQF/HzxVFFoeFNGIkJnARF+2whkAMeZFME/Qw0nDy14vAYrqru58yQZA6rBareJsNjNgKJIFmXla1JSHgAL2NUOcBID+Np+AwkgT8Qb4rSnpbOoJbrfb4fkpkdEM5ayR8XeqMWUoy9L21HW0KSkl1Sv913HWGGHj938Car70lyEjr6qdbEcB01riNJlMYpZlttL96XQa5/P5h63fvwB9JdMok2+55AAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;">\n      <img class="gatsby-resp-image-image" style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px transparent;" alt="React Router and Store are siblings" title="" src="/static/React-Router-Problem-1-ff88c5acb637cc02b4c32c0dbec7eef0-f5084.png" srcset="/static/React-Router-Problem-1-ff88c5acb637cc02b4c32c0dbec7eef0-9835c.png 200w,\n/static/React-Router-Problem-1-ff88c5acb637cc02b4c32c0dbec7eef0-2db6c.png 400w,\n/static/React-Router-Problem-1-ff88c5acb637cc02b4c32c0dbec7eef0-f5084.png 683w" sizes="(max-width: 683px) 100vw, 683px">\n    </span>\n  </span>\n  </figure>\n<h2 id="square-peg-round-hole"><a href="#square-peg-round-hole" aria-hidden="true" class="anchor"><span aria-hidden=\'true\' class=\'anchor-icon\' /></a>Square Peg, Round Hole</h2>\n<p>On our tour of the Redux/React Router battlefield, we’ve seen a few things:</p>\n<ul>\n<li>React Router assumes that certain &#8220;container&#8221; components should have a say in state architecture. Redux liberates your components from making any decisions about state.</li>\n<li>Mixing these responsibilities creates coupling between your state container and your view layer.</li>\n<li>Deriving from both Redux and React Router require coupling your selectors to the view layer.</li>\n<li>Some powerful abstractions over Redux primitives become impossible with React Router since it hoards router state.</li>\n</ul>\n<p>With that in mind, it’s clear that React Router isn’t a good fit for our breed of purely functional, view-decoupled Redux applications.</p>\n<h2 id="integration-libraries-to-the-rescue"><a href="#integration-libraries-to-the-rescue" aria-hidden="true" class="anchor"><span aria-hidden=\'true\' class=\'anchor-icon\' /></a>Integration Libraries to the Rescue?</h2>\n<p>What about libraries like <a href="https://github.com/reactjs/react-router-redux">redux-react-router</a> or <a href="https://github.com/acdlite/redux-router">redux-router</a>? Are they good enough couples’ therapy for Redux and React Router to stay together? My answer is a resounding no. In <a href="https://formidable.com/blog/2016/07/19/let-the-url-do-the-talking-part-2-bargaining-and-acceptance-with-redux-and-react-router/">part 2 of this series,</a> we’ll see that these libraries may not do what you expect.</p>\n<div>\n          <div\n            class="gatsby-resp-iframe-wrapper"\n            style="padding-bottom: 9.090909090909092%; position: relative; height: 0; overflow: hidden;"\n          >\n            <iframe src="https://ghbtns.com/github-btn.html?user=formidablelabs&amp;repo=redux-little-router&amp;type=star&amp;count=true&amp;size=large" frameborder="0" scrolling="0" style="\n            position: absolute;\n            top: 0;\n            left: 0;\n            width: 100%;\n            height: 100%;\n          "></iframe>\n          </div>\n          </div>\n<div>\n          <div\n            class="gatsby-resp-iframe-wrapper"\n            style="padding-bottom: 9.090909090909092%; position: relative; height: 0; overflow: hidden;"\n          >\n            <iframe src="https://ghbtns.com/github-btn.html?user=tptee&amp;type=follow&amp;count=true&amp;size=large" frameborder="0" scrolling="0" style="\n            position: absolute;\n            top: 0;\n            left: 0;\n            width: 100%;\n            height: 100%;\n          "></iframe>\n          </div>\n          </div>',fields:{slug:"/blog/2016/07/11/let-the-url-do-the-talking-part-1-the-pain-of-react-router-in-redux/"},frontmatter:{id:16,authorId:7,categoryIds:[1],date:"2016-07-11",pageDescription:"",pageKeywords:"",pageTitle:"",path:"/2016/07/11/let-the-url-do-the-talking-part-1-the-pain-of-react-router-in-redux/",title:"Let the URL do the Talking, Part 1: The Pain of React Router in Redux"}}},pathContext:{slug:"/blog/2016/07/11/let-the-url-do-the-talking-part-1-the-pain-of-react-router-in-redux/",prev:{fields:{slug:"/blog/2016/06/20/radium-grid-a-react-grid-system-injected-with-the-power-of-radium/"},frontmatter:{authorId:7,categoryIds:[5,12,1],date:"2016-06-20",id:15,title:"Radium Grid: A React Grid System Injected with the Power of Radium"}}}}}});