webpackJsonp([0xfaf192d0649e],{716:function(n,s){n.exports={data:{markdownRemark:{html:'<p>For <a href="https://formidable.com/blog/2016/05/24/announcing-spectacle-editor-a-work-in-progress/">Spectacle Editor</a>, our current collaboration with Plot.ly, we decided to use <a href="https://mobxjs.github.io/mobx/index.html">MobX</a> to handle application state instead of <a href="http://redux.js.org/">Redux</a>. Redux is an amazing framework, and here at Formidable we continue to use it on new and existing client projects with great results. In part, the decision to use MobX was driven by a desire to test a new approach to React app state, learn new patterns, and challenge our assumptions. Spectacle Editor also has more flexibility in terms of architectural direction: it is not server rendered; there’s virtually no routing, and as an <a href="http://electron.atom.io/">Electron</a> app, it is only targeting one browser. That said, there are some clear reasons why MobX makes sense for an open source presentation editor.</p>\n<h2 id="short-learning-curve"><a href="#short-learning-curve" aria-hidden="true" class="anchor"><span aria-hidden=\'true\' class=\'anchor-icon\' /></a>Short learning curve</h2>\n<p>MobX has a very small <a href="https://mobxjs.github.io/mobx/refguide/api.html">API surface area</a> and requires minimal boilerplate. This makes it easy to onboard new developers and have them be productive quickly. The small boilerplate footprint creates code that is both explicit and simple to follow. The core concepts in Spectacle Editor are observable values, computed values, observer, transactions, and autorun. MobX recently announced <a href="https://medium.com/p/45cdc73c7c8d/">support for actions</a>, but we’re currently having components call methods directly on the single store instance for simplicity. As the application grows to more stores, we will probably leverage actions to keep code organized. MobX has <a href="https://mobxjs.github.io/mobx/">excellent documentation</a>, but I’ll illustrate some of our use cases with its API below.</p>\n<h3 id="observables"><a href="#observables" aria-hidden="true" class="anchor"><span aria-hidden=\'true\' class=\'anchor-icon\' /></a>Observables</h3>\n<p>The <a href="https://mobxjs.github.io/mobx/refguide/observable.html"><code>observable</code></a> function/decorator in MobX turns a property into a publisher so that other pieces of the app can subscribe to changes. The main observable of Spectacle Editor is the history of the array of slides that a user is editing. Side note: this history is immutable thanks to <a href="https://github.com/rtfeldman/seamless-immutable">seamless-immutable</a>. This enables undo and redo functionality. Redux has an excellent guide on <a href="http://redux.js.org/docs/recipes/ImplementingUndoHistory.html">application history</a> and the implementation in MobX for Spectacle Editor is fairly similar. History in Spectacle editor looks like this:</p>\n<div class="gatsby-highlight">\n      <pre class="language-js"><code class="language-js"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">class</span> <span class="token class-name">SlidesStore</span> <span class="token punctuation">{</span>\n  <span class="token comment">// Observable history array</span>\n  @observable history <span class="token operator">=</span> Immutable<span class="token punctuation">.</span><span class="token keyword">from</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">{</span>\n    currentSlideIndex<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span>\n    slides<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">{</span>\n      <span class="token comment">// Default first slide</span>\n    <span class="token punctuation">}</span><span class="token punctuation">]</span>\n  <span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">)</span>\n\n  <span class="token comment">// Start state at the first entry in history</span>\n  @observable historyIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code></pre>\n      </div>\n<p>Updates to observables are done by updating the value. This allows for explicit store code that reads as the author intended.</p>\n<div class="gatsby-highlight">\n      <pre class="language-text"><code class="language-text">addToHistory(snapshot) {\n  this.history = this.history.concat([Immutable.from(snapshot)]);\n  this.historyIndex += 1;\n}</code></pre>\n      </div>\n<h3 id="computed-values"><a href="#computed-values" aria-hidden="true" class="anchor"><span aria-hidden=\'true\' class=\'anchor-icon\' /></a>Computed values</h3>\n<p><a href="https://mobxjs.github.io/mobx/refguide/computed-decorator.html">Computed values</a> subscribe to changes in observables and update their output accordingly. From the MobX docs, “Use <code>@computed</code> if you have a value that can be derived in a pure manner from other observables”. Computed values themselves are also observables, so you can build computed values that are based entirely on other comupted values. In practice, we ended up with minimal observables and many computed values. The resulting computed values are clear and easy to reason about. With history, we can derive if undo and redo are disabled depending on the length of the history array and current history index. Current state is computed as the item in history at history index.</p>\n<div class="gatsby-highlight">\n      <pre class="language-js"><code class="language-js">@computed <span class="token keyword">get</span> <span class="token function">undoDisabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>historyIndex <span class="token operator">===</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token keyword">this</span><span class="token punctuation">.</span>history<span class="token punctuation">.</span>length <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n@computed <span class="token keyword">get</span> <span class="token function">redoDisabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>historyIndex <span class="token operator">>=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>history<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n@computed <span class="token keyword">get</span> <span class="token function">currentState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>history<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>historyIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code></pre>\n      </div>\n<h3 id="observer"><a href="#observer" aria-hidden="true" class="anchor"><span aria-hidden=\'true\' class=\'anchor-icon\' /></a>Observer</h3>\n<p>The <a href="https://mobxjs.github.io/mobx/refguide/observer-component.html"><code>observer</code></a> function/decorator is the counterpart to <code>observable</code> and runs when a subscribed-to observable changes. This is one of the few pieces of MobX that is explicitly tied to React and takes a React component class as its only argument (note: it even lives in a separate npm package <a href="https://github.com/mobxjs/mobx-react"><code>mobx-react</code></a>). MobX handles rerendering the component only when the specific observables and computed values that the component depends on changes. The MobX docs have a great guide on <a href="https://mobxjs.github.io/mobx/best/react-performance.html">optimizing for performance</a>. In Spectacle Editor, any component that accesses store data directly is wrapped in an observer decorator.</p>\n<h3 id="autorun"><a href="#autorun" aria-hidden="true" class="anchor"><span aria-hidden=\'true\' class=\'anchor-icon\' /></a>Autorun</h3>\n<p><a href="https://mobxjs.github.io/mobx/refguide/autorun.html"><code>autorun</code></a> is similar to <code>computed</code> and <code>observer</code> in that it runs every time an observable dependency changes. It’s different in that it is specifically for creating side effects. <code>autorun</code> is useful for the cases where you’re not computing a new observable or rerendering a component but instead, creating side effects. This is useful in testing, logging, persistence, and UI updates that don’t map directly to react. In Spectacle Editor, there’s an interaction with <a href="https://github.com/chenglou/react-motion">react-motion</a> where an animation delay is required so local state can’t directly follow store state. I expect we’ll uncover more cases where autorun is useful as we build other complex UI features. Be aware that <code>autorun</code> will call the callback immediately when calling autorun. For instance, with DOM interaction side-effects put the <code>autorun</code> statement in <code>componentDidMount</code> to be safe.</p>\n<h4>Note about magical binding</h4>\n<p>Computed values, observer classes, and autorun functions are slightly magical in the way that merely accessing an observable within their scope subscribes them to that observable’s changes. That said, the benefits of readable, clean, and performant code are worth the hidden complexity in my opinion. The <a href="https://github.com/mobxjs/mobx/blob/master/src/">MobX source code</a> is worth reading if you’re interested in what’s happening under the hood.</p>\n<h3 id="transactions"><a href="#transactions" aria-hidden="true" class="anchor"><span aria-hidden=\'true\' class=\'anchor-icon\' /></a>Transactions</h3>\n<p><a href="https://mobxjs.github.io/mobx/refguide/transaction.html"><code>transaction</code></a> is a method that batches any updates to observables. Subscribers to the observables changes in the transaction are only notified once all code within the transaction has completed. This is useful when updating more than one observable because it prevents unnecessary render/compute cycles. With transactions, our <code>addToHistory</code> method only notifies subscribers once changes to <code>history</code> and <code>historyIndex</code> are both finished.</p>\n<div class="gatsby-highlight">\n      <pre class="language-js"><code class="language-js"><span class="token comment">// NOTE: Cap history array length to some number to prevent absurd memory leaks</span>\n  <span class="token function">addToHistory</span><span class="token punctuation">(</span>snapshot<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// Only notify observers once all expressions have completed</span>\n    <span class="token function">transaction</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n      <span class="token comment">// If we have a future and we do an action, remove the future.</span>\n      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>historyIndex <span class="token operator">&lt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>history<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">this</span><span class="token punctuation">.</span>history <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>history<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>historyIndex <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n\n      <span class="token keyword">this</span><span class="token punctuation">.</span>history <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>history<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token punctuation">[</span>Immutable<span class="token punctuation">.</span><span class="token keyword">from</span><span class="token punctuation">(</span>snapshot<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token keyword">this</span><span class="token punctuation">.</span>historyIndex <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span></code></pre>\n      </div>\n<h2 id="powerful-primitives"><a href="#powerful-primitives" aria-hidden="true" class="anchor"><span aria-hidden=\'true\' class=\'anchor-icon\' /></a>Powerful primitives</h2>\n<p>MobX’s API is easy to grasp while still allowing for complex state update behavior. It feels very natural to explicitly set the state desired based on input and let MobX handle the updates to subscribers. With the above setup for observable history and computed values for <code>undoDisabled</code>, <code>redoDisabled</code>, and <code>currentState</code>, it’s simple to create undo and redo functions.</p>\n<div class="gatsby-highlight">\n      <pre class="language-js"><code class="language-js"><span class="token function">undo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// double check we\'re not trying to undo without history</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>historyIndex <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token keyword">this</span><span class="token punctuation">.</span>historyIndex <span class="token operator">-=</span> <span class="token number">1</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token function">redo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// Double check we\'ve got a future to redo to</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>historyIndex <span class="token operator">></span> <span class="token keyword">this</span><span class="token punctuation">.</span>history<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token keyword">this</span><span class="token punctuation">.</span>historyIndex <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code></pre>\n      </div>\n<h2 id="testing"><a href="#testing" aria-hidden="true" class="anchor"><span aria-hidden=\'true\' class=\'anchor-icon\' /></a>Testing</h2>\n<p>Testing the interaction between stores and React components can be tricky. MobX makes this straightforward with autorun, which allows us to effectively mock consumers of state changes. Autorun matches the observer function/decorator so we can be sure that if autorun is/isn’t running with the correct values, the observer components will too. To follow with the history example, here’s how we test that the addToHistory transaction only notifies observers once per addToHistory call and that the state is correct.</p>\n<div class="gatsby-highlight">\n      <pre class="language-js"><code class="language-js"><span class="token keyword">const</span> testStore <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Store</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token comment">// Set initial state</span>\n  testStore<span class="token punctuation">.</span>history <span class="token operator">=</span> Immutable<span class="token punctuation">.</span><span class="token keyword">from</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">"a"</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  testStore<span class="token punctuation">.</span>historyIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>\n\n  <span class="token keyword">const</span> historySpy <span class="token operator">=</span> <span class="token function">spy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">const</span> historyIndexSpy <span class="token operator">=</span> <span class="token function">spy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token comment">// Autorun invokes the callback immediatly and adds listeners</span>\n  <span class="token comment">// for all observables in the callback scope.</span>\n  <span class="token keyword">const</span> disposer <span class="token operator">=</span> <span class="token function">autorun</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n    <span class="token function">historySpy</span><span class="token punctuation">(</span>testStore<span class="token punctuation">.</span>history<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token function">historyIndexSpy</span><span class="token punctuation">(</span>testStore<span class="token punctuation">.</span>historyIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token comment">// Verify that autorun invoked the spy once on initialization</span>\n  <span class="token function">expect</span><span class="token punctuation">(</span>historySpy<span class="token punctuation">.</span>callCount<span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">.</span><span class="token function">equal</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token function">expect</span><span class="token punctuation">(</span>historyIndexSpy<span class="token punctuation">.</span>callCount<span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">.</span><span class="token function">equal</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token comment">// Verify that autorun was called with the initial values</span>\n  <span class="token comment">// args[0][0] gets the first call then the first entry in arguments array.</span>\n  <span class="token function">expect</span><span class="token punctuation">(</span>historySpy<span class="token punctuation">.</span>args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">.</span><span class="token function">eql</span><span class="token punctuation">(</span>Immutable<span class="token punctuation">.</span><span class="token keyword">from</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">"a"</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token function">expect</span><span class="token punctuation">(</span>historyIndexSpy<span class="token punctuation">.</span>args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">.</span><span class="token function">eql</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token comment">// Call our function that should trigger autorun</span>\n  testStore<span class="token punctuation">.</span><span class="token function">addToHistory</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"b"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token comment">// Verify that transaction only reran autorun once.</span>\n  <span class="token function">expect</span><span class="token punctuation">(</span>historySpy<span class="token punctuation">.</span>callCount<span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">.</span><span class="token function">equal</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token function">expect</span><span class="token punctuation">(</span>historyIndexSpy<span class="token punctuation">.</span>callCount<span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">.</span><span class="token function">equal</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token comment">// Verify the values passed to autorun were the expected values</span>\n  <span class="token comment">// args[1][0] gets the second call then the first entry in arguments array.</span>\n  <span class="token function">expect</span><span class="token punctuation">(</span>historySpy<span class="token punctuation">.</span>args<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">.</span><span class="token function">eql</span><span class="token punctuation">(</span>Immutable<span class="token punctuation">.</span><span class="token keyword">from</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">"a"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">"b"</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token function">expect</span><span class="token punctuation">(</span>historyIndexSpy<span class="token punctuation">.</span>args<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">.</span><span class="token function">eql</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token comment">// Remove autorun. This belongs in an after/afterEach statement.</span>\n  <span class="token function">disposer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>\n      </div>\n<h2 id="less-boilerplate-more-application-code"><a href="#less-boilerplate-more-application-code" aria-hidden="true" class="anchor"><span aria-hidden=\'true\' class=\'anchor-icon\' /></a>Less boilerplate, more application code.</h2>\n<p>With the API outlined above, we’ve created a store whose state representation is clearly outlined in code. Within the store, MobX’s footprint is limited to the initial @observable, @computed, and the occasional transaction. All of which add clarity to the behavior of the code. For components, we borrowed the <a href="https://github.com/reactjs/react-redux/blob/master/docs/api.md#provider-store">provider pattern from redux</a> and pass the store down on context. Any component that depends on store state has an @observer decorator. Components only access the pieces of state they rely on and MobX handles the rerenders when those specific pieces change. There is very little plumbing yet the app is flexible and easy to reason about.</p>\n<h2 id="conclusion"><a href="#conclusion" aria-hidden="true" class="anchor"><span aria-hidden=\'true\' class=\'anchor-icon\' /></a>Conclusion</h2>\n<p>Spectacle Editor is far from a representative sample of current React apps. It doesn’t require server rendering, cross browser compatibility, or complex state changes based on routing. This project had flexibility in architecture and we are using the opportunity to expand our knowledge and share these findings with the community. The decision to use <a href="https://mobxjs.github.io/mobx/index.html">MobX</a> over <a href="http://redux.js.org/">Redux</a> was not taken lightly and this post is not meant to replace due diligence based on project requirements. MobX allows us to write clean, testable, and maintainable code for this project. So far, there haven’t been any snags with MobX getting in the way of functionality or limiting UI capabilities. The API is small but powerful, testing is straightforward, and boilerplate code is virtually non-existent. Like React, MobX is a framework with the right level of abstraction that allows for complex code behavior while still letting application code take center stage.</p>\n<div>\n          <div\n            class="gatsby-resp-iframe-wrapper"\n            style="padding-bottom: 9.090909090909092%; position: relative; height: 0; overflow: hidden;"\n          >\n            <iframe src="https://ghbtns.com/github-btn.html?user=formidablelabs&amp;repo=spectacle-editor&amp;type=star&amp;count=true&amp;size=large" frameborder="0" style="\n            position: absolute;\n            top: 0;\n            left: 0;\n            width: 100%;\n            height: 100%;\n          "></iframe>\n          </div>\n          </div>\n<div>\n          <div\n            class="gatsby-resp-iframe-wrapper"\n            style="padding-bottom: 9.090909090909092%; position: relative; height: 0; overflow: hidden;"\n          >\n            <iframe src="https://ghbtns.com/github-btn.html?user=rgerstenberger&amp;type=follow&amp;count=true&amp;size=large" frameborder="0" scrolling="0" style="\n            position: absolute;\n            top: 0;\n            left: 0;\n            width: 100%;\n            height: 100%;\n          "></iframe>\n          </div>\n          </div>',fields:{slug:"/blog/2016/06/02/why-we-chose-mobx-over-redux-for-spectacle-editor/"},frontmatter:{id:14,authorId:10,categoryIds:[5,13],date:"2016-06-02",pageDescription:"",pageKeywords:"",pageTitle:"",path:"/2016/06/02/why-we-chose-mobx-over-redux-for-spectacle-editor/",title:"Why we chose MobX over Redux for Spectacle Editor"}}},pathContext:{slug:"/blog/2016/06/02/why-we-chose-mobx-over-redux-for-spectacle-editor/",prev:{fields:{slug:"/blog/2016/05/24/announcing-spectacle-editor-a-work-in-progress/"},frontmatter:{authorId:10,categoryIds:[5,13],date:"2016-05-24",id:13,title:"Announcing Spectacle Editor, a Work In Progress"}}}}}});