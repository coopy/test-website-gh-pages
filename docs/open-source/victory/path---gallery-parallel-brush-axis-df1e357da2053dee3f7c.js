webpackJsonp([93447138781512],{866:function(t,e){t.exports={data:{markdownRemark:{html:'<pre class="pre"><code class="language-playground_norender">const data = [\n  { name: &quot;Adrien&quot;, strength: 5, intelligence: 30, speed: 500, luck: 3 },\n  { name: &quot;Brice&quot;, strength: 1, intelligence: 13, speed: 550, luck: 2 },\n  { name: &quot;Casey&quot;, strength: 4, intelligence: 15, speed: 80, luck: 1 },\n  { name: &quot;Drew&quot;, strength: 3, intelligence: 25, speed: 600, luck: 5 },\n  { name: &quot;Erin&quot;, strength: 9, intelligence: 50, speed: 350, luck: 4 },\n  { name: &quot;Francis&quot;, strength: 2, intelligence: 40, speed: 200, luck: 2 }\n];\nconst attributes = [&quot;strength&quot;, &quot;intelligence&quot;, &quot;speed&quot;, &quot;luck&quot;];\nconst height = 500;\nconst width = 500;\nconst padding = { top: 100, left: 50, right: 50, bottom: 50 };\n\nclass App extends React.Component {\n  constructor() {\n    super();\n    const maximumValues = this.getMaximumValues();\n    const datasets = this.normalizeData(maximumValues);\n    this.state = {\n      maximumValues, datasets, filters: {}, activeDatasets: [], isFiltered: false\n    };\n  }\n\n  getMaximumValues() {\n    // Find the maximum value for each axis. This will be used to normalize data and re-scale axis ticks\n    return attributes.map((attribute) =&gt; {\n      return data.reduce((memo, datum) =&gt; {\n        return datum[attribute] &gt; memo ? datum[attribute] : memo;\n      }, -Infinity);\n    });\n  }\n\n  normalizeData(maximumValues) {\n    // construct normalized datasets by dividing the value for each attribute by the maximum value\n    return data.map((datum) =&gt; ({\n      name: datum.name,\n      data: attributes.map((attribute, i) =&gt; (\n        { x: attribute, y: datum[attribute] / maximumValues[i] }\n      ))\n    }));\n  }\n\n  addNewFilters(domain, props) {\n    const filters = this.state.filters || {};\n    const extent = domain &amp;&amp; Math.abs(domain[1] - domain[0]);\n    const minVal = 1 / Number.MAX_SAFE_INTEGER;\n    filters[props.name] = extent &lt;= minVal ? undefined : domain;\n    return filters;\n  }\n\n  getActiveDatasets(filters) {\n    // Return the names from all datasets that have values within all filters\n    const isActive = (dataset) =&gt; {\n      return _.keys(filters).reduce((memo, name) =&gt; {\n        if (!memo || !Array.isArray(filters[name])) {\n          return memo;\n        }\n        const point = _.find(dataset.data, (d) =&gt; d.x === name);\n        return point &amp;&amp;\n          Math.max(...filters[name]) &gt;= point.y &amp;&amp; Math.min(...filters[name]) &lt;= point.y;\n      }, true);\n    };\n\n    return this.state.datasets.map((dataset) =&gt; {\n      return isActive(dataset, filters) ? dataset.name : null;\n    }).filter(Boolean);\n  }\n\n  onDomainChange(domain, props) {\n    const filters = this.addNewFilters(domain, props);\n    const isFiltered = !_.isEmpty(_.values(filters).filter(Boolean));\n    const activeDatasets = isFiltered ? this.getActiveDatasets(filters) : this.state.datasets;\n    this.setState({ activeDatasets, filters, isFiltered });\n  }\n\n  isActive(dataset) {\n    // Determine whether a given dataset is active\n    return !this.state.isFiltered ? true : _.includes(this.state.activeDatasets, dataset.name);\n  }\n\n  getAxisOffset(index) {\n    const step = (width - padding.left - padding.right) / (attributes.length - 1);\n    return step * index + padding.left;\n  }\n\n  render() {\n    return (\n      &lt;VictoryChart domain={{ y: [0, 1.1] }}\n        height={height} width={width} padding={padding}\n      &gt;\n        &lt;VictoryAxis\n          style={{\n            tickLabels: { fontSize: 20 }, axis: { stroke: &quot;none&quot; }\n          }}\n          tickLabelComponent={&lt;VictoryLabel y={padding.top - 40}/&gt;}\n        /&gt;\n        {this.state.datasets.map((dataset) =&gt; (\n          &lt;VictoryLine\n            key={dataset.name} name={dataset.name} data={dataset.data}\n            groupComponent={&lt;g/&gt;}\n            style={{ data: {\n              stroke: &quot;tomato&quot;,\n              opacity: this.isActive(dataset) ? 1 : 0.2\n            } }}\n          /&gt;\n        ))}\n        {attributes.map((attribute, index) =&gt; (\n          &lt;VictoryAxis dependentAxis\n            key={index}\n            axisComponent={\n              &lt;VictoryBrushLine name={attribute}\n                width={20}\n                onBrushDomainChange={this.onDomainChange.bind(this)}\n              /&gt;\n            }\n            offsetX={this.getAxisOffset(index)}\n            style={{\n              tickLabels: { fontSize: 15, padding: 15, pointerEvents: &quot;none&quot; },\n            }}\n            tickValues={[0.2, 0.4, 0.6, 0.8, 1]}\n            tickFormat={(tick) =&gt; Math.round(tick * this.state.maximumValues[index])}\n          /&gt;\n        ))}\n      &lt;/VictoryChart&gt;\n    );\n  }\n}\n\nReactDOM.render(&lt;App/&gt;, mountNode);</code></pre>',frontmatter:{id:0,scope:null,title:"Parallel Brush Axes"},fields:{slug:"/gallery/parallel-brush-axis/"}}},pathContext:{slug:"/gallery/parallel-brush-axis/"}}}});
//# sourceMappingURL=path---gallery-parallel-brush-axis-df1e357da2053dee3f7c.js.map