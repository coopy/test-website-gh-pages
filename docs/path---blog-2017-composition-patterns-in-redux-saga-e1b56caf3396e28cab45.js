webpackJsonp([79463157664763],{741:function(n,s){n.exports={data:{markdownRemark:{html:'<p>In the <a href="https://formidable.com/blog/2017/javascript-power-tools-redux-saga/">last article</a>, we investigated <code class="language-text">redux-saga</code>’s approach to the Saga pattern\nin JavaScript. Specifically, the concept of a generator function that yields\n‘command objects’, which <em>describe</em> the effects we want to happen, and rely on an\nexternal driver to actually perform those effects. We observed that such a\ngenerator function is called a ‘saga’.</p>\n<p>Now that we understand the mechanism of action, we can start looking at some of\nthe ways <code class="language-text">redux-saga</code> allows us to <em>compose</em> sagas.</p>\n<p>When I say, “compose sagas,” I’m referring to the different ways to start a saga from\nwithin another one. Why do I say “start” instead of “call”? Because sagas start\nmaking much more sense when you think of them as <em>subprograms</em> rather than as\nfancy patterns for constructing functions.</p>\n<p>First, let’s go back to what we learned in the last article -  we’ll begin by invoking an async function from within a saga.</p>\n<div class="gatsby-highlight">\n      <pre class="language-js"><code class="language-js"><span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">serverHello</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> response <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token function">call</span><span class="token punctuation">(</span>fetch<span class="token punctuation">,</span> <span class="token string">\'example.com\'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> method<span class="token punctuation">:</span> <span class="token string">\'POST\'</span><span class="token punctuation">,</span> body<span class="token punctuation">:</span> name <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">const</span> text <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">[</span>response<span class="token punctuation">,</span> response<span class="token punctuation">.</span>text<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">return</span> text<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">rootSaga</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token function">call</span><span class="token punctuation">(</span>serverHello<span class="token punctuation">,</span> <span class="token string">"world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token keyword">yield</span> <span class="token function">call</span><span class="token punctuation">(</span>console<span class="token punctuation">.</span>log<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code></pre>\n      </div>\n<p>In <code class="language-text">serverHello</code>, we’re making two asynchronous function calls: the first\ninvokes <code class="language-text">fetch</code> and waits for a response to become available, and the second\nunwraps the response body text. In each case, we say that <code class="language-text">serverHello</code> is\n<em>blocking</em> on the result of the asynchronous function.</p>\n<p>By the same token, <code class="language-text">rootSaga</code> is <em>blocking</em> on the result of  another saga, <code class="language-text">serverHello</code>. It won’t continue executing until the return value of\n<code class="language-text">serverHello</code> is available.</p>\n<p>In some cases, this is a good thing. If we need to make two API calls, and the\n<em>order matters</em>, this forces them to occur in a specific order.</p>\n<div class="gatsby-highlight">\n      <pre class="language-js"><code class="language-js"><span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">rootSaga</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n <span class="token comment">// Blocked until first serverHello finishes</span>\n <span class="token keyword">const</span> result0 <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token function">call</span><span class="token punctuation">(</span>serverHello<span class="token punctuation">,</span> <span class="token string">\'world\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n <span class="token comment">// blocked until second serverHello finishes</span>\n <span class="token keyword">const</span> result1 <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token function">call</span><span class="token punctuation">(</span>serverHello<span class="token punctuation">,</span> <span class="token string">\'Matt\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n <span class="token keyword">yield</span> <span class="token function">call</span><span class="token punctuation">(</span>console<span class="token punctuation">.</span>log<span class="token punctuation">,</span> result0<span class="token punctuation">)</span><span class="token punctuation">;</span>\n <span class="token keyword">yield</span> <span class="token function">call</span><span class="token punctuation">(</span>console<span class="token punctuation">.</span>log<span class="token punctuation">,</span> result1<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code></pre>\n      </div>\n<p>However, in many cases, <code class="language-text">rootSaga</code> might not need the result right away and\ncould be doing other work in the meantime.</p>\n<div class="gatsby-highlight">\n      <pre class="language-js"><code class="language-js"><span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">rootSaga</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// Returns immediately with a Task object</span>\n  <span class="token keyword">const</span> task <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token function">spawn</span><span class="token punctuation">(</span>serverHello<span class="token punctuation">,</span> <span class="token string">\'world\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token comment">// Perform an effect in the meantime</span>\n  <span class="token keyword">yield</span> <span class="token function">call</span><span class="token punctuation">(</span>console<span class="token punctuation">.</span>log<span class="token punctuation">,</span> <span class="token string">"waiting on server result..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token comment">// Block on the result of serverHello</span>\n  <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token function">join</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token comment">// Use the result of serverHello</span>\n  <span class="token keyword">yield</span> <span class="token function">call</span><span class="token punctuation">(</span>console<span class="token punctuation">.</span>log<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code></pre>\n      </div>\n<p>Here, we use the <em>non-blocking</em> <code class="language-text">spawn</code> effect to tell <code class="language-text">redux-saga</code>\nthat it should start the child saga, but resume <code class="language-text">rootSaga</code> immediately. In this\ncase, the return value of the <code class="language-text">spawn</code> effect is not the <em>result</em> of\n<code class="language-text">serverHello</code>, but rather a “Task object” which acts as a handle to\n<code class="language-text">serverHello</code>. <code class="language-text">rootSaga</code> is free to continue execution until we decide we\nactually need a result. At this point, we yield <code class="language-text">join</code> with the Task object,\nwhich instructs <code class="language-text">redux-saga</code> to wait for the associated saga (<code class="language-text">serverHello</code>) to\nfinish before resuming <code class="language-text">rootSaga</code>. The result of <code class="language-text">serverHello</code> then becomes the\nreturn value of <code class="language-text">join</code>.</p>\n<p>With these two primitives, we can reconstruct our previous blocking calls.</p>\n<div class="gatsby-highlight">\n      <pre class="language-js"><code class="language-js"><span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">rootSaga</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> task0 <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token function">spawn</span><span class="token punctuation">(</span>serverHello<span class="token punctuation">,</span> <span class="token string">\'world\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">const</span> result0 <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token function">join</span><span class="token punctuation">(</span>task0<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token keyword">const</span> task1 <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token function">spawn</span><span class="token punctuation">(</span>serverHello<span class="token punctuation">,</span> <span class="token string">\'Matt\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">const</span> result1 <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token function">join</span><span class="token punctuation">(</span>task1<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token keyword">yield</span> <span class="token function">call</span><span class="token punctuation">(</span>console<span class="token punctuation">.</span>log<span class="token punctuation">,</span> result0<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">yield</span> <span class="token function">call</span><span class="token punctuation">(</span>console<span class="token punctuation">.</span>log<span class="token punctuation">,</span> result1<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code></pre>\n      </div>\n<p>We wouldn’t write “real code” this way, but it’s useful to realize\nthat a series of <code class="language-text">call</code> effects can be rewritten as a series of <code class="language-text">spawn/join</code>\npairs.</p>\n<p>What if we wanted to run those effects in parallel, rather than in a series?</p>\n<div class="gatsby-highlight">\n      <pre class="language-js"><code class="language-js"><span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">rootSaga</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> task0 <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token function">spawn</span><span class="token punctuation">(</span>serverHello<span class="token punctuation">,</span> <span class="token string">\'world\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">const</span> task1 <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token function">spawn</span><span class="token punctuation">(</span>serverHello<span class="token punctuation">,</span> <span class="token string">\'Matt\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token keyword">const</span> <span class="token punctuation">[</span>result0<span class="token punctuation">,</span> result1<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token function">join</span><span class="token punctuation">(</span>task0<span class="token punctuation">,</span> task1<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token keyword">yield</span> <span class="token function">call</span><span class="token punctuation">(</span>console<span class="token punctuation">.</span>log<span class="token punctuation">,</span> result0<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">yield</span> <span class="token function">call</span><span class="token punctuation">(</span>console<span class="token punctuation">.</span>log<span class="token punctuation">,</span> result1<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code></pre>\n      </div>\n<p>We begin by starting both of our child sagas and saving a reference to each one’s Task object.\nThen, by yielding a <code class="language-text">join</code> effect with multiple Task objects, we wait for both\nto complete before resuming. The return value of <code class="language-text">join</code> will become an <em>array</em>\ncontaining each child saga’s result.</p>\n<p>But what if we don’t <em>care</em> about the return value of those child sagas? For\ninstance, what if we only care that a POST to the server finished?</p>\n<div class="gatsby-highlight">\n      <pre class="language-js"><code class="language-js"><span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">rootSaga</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> task0 <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token function">spawn</span><span class="token punctuation">(</span>serverHello<span class="token punctuation">,</span> <span class="token string">\'world\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">const</span> task1 <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token function">spawn</span><span class="token punctuation">(</span>serverHello<span class="token punctuation">,</span> <span class="token string">\'Matt\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token keyword">yield</span> <span class="token function">join</span><span class="token punctuation">(</span>task0<span class="token punctuation">,</span> task1<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code></pre>\n      </div>\n<p>In this case, the <code class="language-text">join</code> effect starts to look like an afterthought,\nthat will trip us up if we don’t remember to include it.</p>\n<p>In many cases, we’ll want a saga to kick off a bunch of non-blocking\neffects and then wait for them to finish before returning. In this case,\nwe’d use the <code class="language-text">fork</code> effect, which creates an <em>attached</em> Task rather than an\n<em>unattached</em> Task. The difference:</p>\n<ul>\n<li>\n<p>A parent saga that <code class="language-text">fork</code>s a child saga will wait for its child to complete before completing itself.</p>\n</li>\n<li>\n<p>If a parent saga is cancelled before its child saga finishes executing, the\nchild saga will be cancelled as well.</p>\n</li>\n</ul>\n<div class="gatsby-highlight">\n      <pre class="language-js"><code class="language-js"><span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">rootSagaWithSpawn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> task0 <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token function">spawn</span><span class="token punctuation">(</span>serverHello<span class="token punctuation">,</span> <span class="token string">\'world\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">const</span> task1 <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token function">spawn</span><span class="token punctuation">(</span>serverHello<span class="token punctuation">,</span> <span class="token string">\'Matt\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token keyword">yield</span> <span class="token function">join</span><span class="token punctuation">(</span>task0<span class="token punctuation">,</span> task1<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">rootSagaWithFork</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">yield</span> <span class="token function">fork</span><span class="token punctuation">(</span>serverHello<span class="token punctuation">,</span> <span class="token string">\'world\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">yield</span> <span class="token function">fork</span><span class="token punctuation">(</span>serverHello<span class="token punctuation">,</span> <span class="token string">\'Matt\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code></pre>\n      </div>\n<p>This example is better, but it still seems a bit… magical. After all, we’re relying on\nthe implicit behavior of the <code class="language-text">fork</code> to make sure both child sagas complete before finishing the execution itself. Moreover, starting up child sagas in parallel is a common pattern, so writing an entire saga to do it seems excessive. Because of this,\n<code class="language-text">redux-saga</code> provides the <code class="language-text">all</code> effect, which takes an array of <em>blocking</em>\neffects and waits for all of them to complete before resuming with all results.</p>\n<div class="gatsby-highlight">\n      <pre class="language-js"><code class="language-js"><span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">rootSaga</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> <span class="token punctuation">[</span>\n    result0<span class="token punctuation">,</span>\n    result1<span class="token punctuation">,</span>\n  <span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token function">all</span><span class="token punctuation">(</span><span class="token punctuation">[</span>\n    <span class="token function">call</span><span class="token punctuation">(</span>serverHello<span class="token punctuation">,</span> <span class="token string">\'world\'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n    <span class="token function">call</span><span class="token punctuation">(</span>serverHello<span class="token punctuation">,</span> <span class="token string">\'Matt\'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n  <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token keyword">yield</span> <span class="token function">call</span><span class="token punctuation">(</span>console<span class="token punctuation">.</span>log<span class="token punctuation">,</span> result0<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">yield</span> <span class="token function">call</span><span class="token punctuation">(</span>console<span class="token punctuation">.</span>log<span class="token punctuation">,</span> result1<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code></pre>\n      </div>\n<p>To bring things full circle, this is more-or-less equivalent to\n<code class="language-text">Promise.all</code>.</p>\n<p>Now that we have a frame of reference for thinking about concurrency in\n<code class="language-text">redux-saga</code>, we can take a look at the kinds of things we can build, which will be the topic of the next article in this series.</p>',fields:{slug:"/blog/2017/composition-patterns-in-redux-saga/"},frontmatter:{id:47,authorId:18,categoryIds:[16,17],date:"2017-05-17",pageDescription:"Take a closer look at the concurrency primitives redux-saga offers.",pageKeywords:"developer, redux-saga, javascript",pageTitle:"JavaScript Power Tools Part II: Composition Patterns in redux-saga",path:"/2017/composition-patterns-in-redux-saga/",title:"JavaScript Power Tools Part II: Composition Patterns in redux-saga"}}},pathContext:{slug:"/blog/2017/composition-patterns-in-redux-saga/",prev:{fields:{slug:"/blog/2017/javascript-power-tools-redux-saga/"},frontmatter:{authorId:18,categoryIds:[16,17],date:"2017-05-10",id:46,title:"JavaScript Power Tools: redux-saga"}}}}}});